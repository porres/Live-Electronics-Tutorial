#N canvas 487 34 646 729 12;
#X declare -path else;
#X obj 468 46 declare -path else;
#X obj 183 297 keyboard 14 70 3 2 1 0 empty empty;
#X floatatom 265 473 5 0 0 0 - - - 0;
#X obj 145 298 tgl 19 0 empty empty empty 0 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X obj 197 601 *~;
#X text 306 473 bpm;
#X obj 145 267 loadbang;
#X obj 197 637 out~;
#X msg 197 380 down;
#X msg 269 380 up, f 2;
#X msg 236 380 alt;
#X msg 300 380 random;
#X floatatom 372 515 6 0 0 0 - - - 0;
#X text 419 516 dur;
#X obj 372 453 knob 50 0 1 0 0.75 empty empty #dfdfdf #7c7c7c black 1 0 0 0 1 320 0 0 0 empty empty 0 12 6 -15 0 1 0 0 0 0;
#X msg 99 452 mul \$1;
#X obj 99 334 vradio 16 1 0 4 empty empty empty 0 -8 0 10 #dfdfdf #000000 #000000 0;
#X obj 99 403 + 1;
#X floatatom 99 426 5 0 0 0 - - - 0;
#X obj 197 562 bl.saw~ -midi;
#X obj 299 595 adsr~ 20 10 0.5 25;
#X obj 265 446 initmess 120;
#X obj 197 503 arpeggiator 120 0.75;
#X obj 197 531 unpack f f, f 15;
#X text 47 28 An arpeggiator can be thought of as some sort of sequencer that plays notes that are being pressed. One way to implement it in Vanilla is with the [bag] object \, as show in its help file and copied below., f 52;
#N canvas 54 50 881 697 Vanilla-arpeggiator 0;
#X obj 557 229 text define notes;
#X msg 557 198 clear;
#X obj 445 160 t b b l b;
#X obj 495 261 text insert notes;
#X msg 455 198 sort;
#X obj 66 399 text get notes;
#X obj 66 341 f;
#X obj 447 297 text size notes;
#X obj 108 363 mod;
#X obj 108 338 + 1;
#X obj 447 331 > 0;
#X obj 447 361 change;
#X obj 66 178 tgl 19 0 empty metro empty 0 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X obj 141 565 line~;
#X msg 141 537 \$1 10;
#X obj 66 499 mtof;
#X obj 66 571 *~;
#X msg 123 200 tempo \$1 permin;
#X floatatom 263 147 5 0 0 0 - bpm - 0;
#X obj 185 263 expr 1/$f1;
#X floatatom 185 237 4 0 0 0 - mul - 0;
#X obj 66 245 metro;
#X obj 263 297 expr 60000/$f1;
#X obj 199 413 *;
#X obj 185 291 t b f;
#X obj 249 405 hsl 162 19 0.25 1 0 0 empty dur empty -2 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X obj 246 452 t b f;
#X obj 66 465 makenote 1;
#X obj 199 490 *;
#X obj 66 601 output~;
#X obj 66 527 tabosc4~ wave, f 8;
#X obj 66 431 route float;
#X obj 495 198 bag -u;
#X msg 444 12 40 127 \, 45 127 \, 49 127 \, 52 127;
#X msg 465 39 40 0 \, 45 0 \, 49 0 \, 52 0;
#X text 664 11 play and hold a chord;
#X text 629 39 release it;
#N canvas 281 271 450 300 init 0;
#X obj 129 65 loadbang;
#X obj 138 222 array define wave 2051;
#X msg 129 95 \; bpm 120 \; mul 4 \; dur 0.75 \; wave sinesum 2048 1 0.5 0.33333 0.25 0.2 0.166667 \, normalize, f 26;
#X connect 0 0 2 0;
#X restore 246 596 pd init;
#X floatatom 66 371 3 0 0 0 - - - 0;
#X text 227 145 BPM;
#X text 154 237 mul;
#X obj 447 389 s metro;
#X floatatom 246 429 5 0 0 0 - - - 0;
#X text 74 34 Below we have a way to sequence through notes stored in a [text] object with a [metro] object. The notes are stored to the right with the help of [bag]., f 40;
#X msg 91 297 -1;
#X msg 126 297 1;
#X text 87 277 down;
#X text 129 277 up;
#X text 383 483 Above \, we clear the [text] contents every time we play a new note and use [bag] to output all of its contents with a bang message. Then the contents of the sequence are sorted and the size of the sequence is queried to use as the module of the sequence counter., f 46;
#X floatatom 263 362 5 0 0 0 - - - 0;
#X text 304 362 ms;
#X floatatom 199 443 4 0 0 0 - - - 0;
#X floatatom 199 517 7 0 0 0 - - - 0;
#X text 255 517 duration;
#X text 290 429 relative duration;
#X obj 444 67 keyboard 17 80 2 2 0 0 empty empty;
#X connect 1 0 0 0;
#X connect 2 0 4 0;
#X connect 2 0 7 0;
#X connect 2 1 32 0;
#X connect 2 2 32 0;
#X connect 2 3 1 0;
#X connect 4 0 0 0;
#X connect 5 0 31 0;
#X connect 6 0 9 0;
#X connect 6 0 38 0;
#X connect 7 0 10 0;
#X connect 7 0 8 1;
#X connect 8 0 6 1;
#X connect 9 0 8 0;
#X connect 10 0 11 0;
#X connect 11 0 41 0;
#X connect 12 0 21 0;
#X connect 13 0 16 1;
#X connect 14 0 13 0;
#X connect 15 0 30 0;
#X connect 16 0 29 0;
#X connect 17 0 21 0;
#X connect 18 0 17 0;
#X connect 18 0 22 0;
#X connect 19 0 21 1;
#X connect 19 0 24 0;
#X connect 20 0 19 0;
#X connect 21 0 6 0;
#X connect 22 0 49 0;
#X connect 23 0 51 0;
#X connect 24 0 23 0;
#X connect 24 1 23 1;
#X connect 25 0 42 0;
#X connect 26 0 28 0;
#X connect 26 1 28 1;
#X connect 27 0 15 0;
#X connect 27 1 14 0;
#X connect 28 0 27 2;
#X connect 28 0 52 0;
#X connect 30 0 16 0;
#X connect 31 0 27 0;
#X connect 32 0 3 0;
#X connect 33 0 55 0;
#X connect 34 0 55 0;
#X connect 38 0 5 0;
#X connect 42 0 26 0;
#X connect 44 0 9 1;
#X connect 45 0 9 1;
#X connect 49 0 23 0;
#X connect 51 0 28 0;
#X connect 55 0 2 0;
#X restore 212 100 pd Vanilla-arpeggiator;
#X text 55 141 ELSE has an abstraction that is similar to the example above \, but with more functionalities. It has different modes: up (default) \, down \, alternating and random. The duration of notes depend on the BPM setting and a beat multiplier value. The default BPM is 120 \, and the multiplier is 4 \, which means that notes are triggered at 1/4 of the 120 bpm beat. The duration of the note is given at a relative ration value - the default 0.75 \, which is 75% of the 1/4 of the 120 bpm beat. Check the help file for more details., f 75;
#X connect 1 0 22 0;
#X connect 2 0 22 1;
#X connect 3 0 22 0;
#X connect 4 0 7 0;
#X connect 6 0 3 0;
#X connect 8 0 22 0;
#X connect 9 0 22 0;
#X connect 10 0 22 0;
#X connect 11 0 22 0;
#X connect 12 0 22 2;
#X connect 14 0 12 0;
#X connect 15 0 22 0;
#X connect 16 0 17 0;
#X connect 17 0 18 0;
#X connect 18 0 15 0;
#X connect 19 0 4 0;
#X connect 20 0 4 1;
#X connect 21 0 2 0;
#X connect 22 0 23 0;
#X connect 23 0 19 0;
#X connect 23 1 20 0;
