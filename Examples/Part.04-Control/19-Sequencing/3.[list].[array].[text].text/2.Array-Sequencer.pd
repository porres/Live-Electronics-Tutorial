#N canvas 366 38 962 704 12;
#X declare -path else;
#X obj 506 254 bng 21 250 50 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000;
#X obj 681 188 cnv 15 198 138 empty empty empty 20 12 0 14 #dcdcdc #404040 0;
#N canvas 91 30 450 300 (subpatch) 0;
#X array sequencer 16 float 2;
#X coords 0 12 16 -12 200 140 1;
#X restore 680 187 graph;
#X text 883 315 -12;
#X text 884 183 12;
#X obj 86 399 tabread sequencer;
#X obj 154 457 nbx 5 16 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 11 #dcdcdc #000000 #000000 0 256;
#X obj 86 447 +;
#X floatatom 86 423 6 0 0 0 - - - 0;
#X obj 86 496 mtof;
#X obj 135 574 *~;
#X floatatom 86 472 7 0 0 0 - - - 0;
#X obj 735 591 osc~;
#X obj 802 536 nbx 5 14 0 200 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X text 796 517 portamento;
#X obj 135 605 out~;
#X obj 735 621 out~;
#X obj 506 287 array get sequencer;
#X obj 153 547 decay2~ 50 500;
#X obj 500 175 array set sequencer;
#X obj 735 562 glide~ 100;
#X text 65 151 The native [tabread] object is used to read values from the array \, then we sum it to the base value and convert to hz. Note we're using floats \, not integers \, hence our sequence is out of the 12 tone equally tempered scale., f 55;
#X floatatom 86 371 5 0 0 0 - - - 0;
#X obj 86 346 count 15;
#X obj 500 131 initmess -5.14286 -7.88572 -7.2 -2.4 -7.2 1.2 4.8 4.11429 -2.4 -4.28572 -4.28572 -0.685715 2.22857 6.17143 7.3 7.1;
#X text 532 254 get values;
#X obj 596 579 value i;
#X text 648 580 (index);
#X text 219 451 transposition (base value), f 13;
#X msg 506 340 -5.14286 -7.88572 -7.2 -2.4 -7.2 1.2 4.8 4.11429 -2.4 -4.28572 -4.28572 -0.685715 2.22857 6.17143 7.3 7.1;
#X obj 783 13 declare -path else;
#X text 497 45 Find below the array used as a sequencer. It is initialized with the native [array set] object. You can also change the values with your mouse and retrieve the values with [array get]. Note that the array can be set to store values when saving the patch.;
#X obj 287 379 array define;
#X obj 521 517 expr i = (i + 1) % 16 \; mtof(rint(sequencer[i] + base));
#X obj 506 312 insert set;
#X text 65 215 We need a metronome and a counter to generate indexes of our sequence stored in the array. The sequence has 16 elements (so the indexes need to be from 0 to 15). Now we just have [tempo] initially on and [counter] doing the index looping., f 55;
#X text 216 302 You can also use [array define] to define and store an array. But we're using a graphical array just so we can see it here., f 31;
#X obj 154 430 initmess 60;
#X obj 86 537 bl.saw~;
#X obj 153 523 b;
#X text 128 371 (0 to 15);
#X text 284 533 instead of [adsr~] \, we're using a [decay2~] object \, with attack and decay., f 19;
#X text 65 57 Let's implement a sequencer using an array to store values (check it to the right). The array can be used to control any parameter in a patch \, but here we just control the MIDI pitch of an oscillator. In this example \, we store 16 values from -12 to 12 and add it to base value (initially 60 \, which is middle C)., f 55;
#X obj 154 489 v base;
#X text 208 489 to load in [expr];
#X text 475 397 Now here's an alternative with [expr] \, which can read values from a table and use variables from a [value] object. But we're rounding to integer values before converting to hz (so we're considering semitones only) and using a [gilde~] object for portamento.;
#X obj 86 322 tempo -on 160;
#X obj 521 490 tempo -on 180;
#X connect 0 0 17 0;
#X connect 5 0 8 0;
#X connect 6 0 7 1;
#X connect 6 0 43 0;
#X connect 7 0 11 0;
#X connect 8 0 7 0;
#X connect 9 0 38 0;
#X connect 9 0 39 0;
#X connect 10 0 15 0;
#X connect 11 0 9 0;
#X connect 12 0 16 0;
#X connect 13 0 20 1;
#X connect 17 0 34 0;
#X connect 18 0 10 1;
#X connect 20 0 12 0;
#X connect 22 0 5 0;
#X connect 23 0 22 0;
#X connect 24 0 19 0;
#X connect 33 1 20 0;
#X connect 34 0 29 0;
#X connect 37 0 6 0;
#X connect 38 0 10 0;
#X connect 39 0 18 0;
#X connect 46 0 23 0;
#X connect 47 0 33 0;
