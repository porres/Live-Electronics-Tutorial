#N canvas 476 78 652 490 12;
#X declare -path else;
#X obj 389 411 nbx 5 14 64 1e+37 0 0 empty empty empty 0 -8 0 10 -228856
-1 -1 2048 256;
#X obj 389 363 hradio 15 1 0 8 empty \$0-set-window empty 0 -8 0 10
-228856 -1 -1 5;
#X obj 389 386 expr pow(2 \, $f1 + 6);
#N canvas 344 26 427 302 Window 0;
#X obj 102 160 s \$0-set-block;
#X msg 102 133 set \$1 \$2;
#X obj 72 231 v w_size_\$0;
#X obj 175 102 v overlap_\$0;
#X obj 79 51 inlet;
#X obj 156 58 inlet;
#X obj 89 197 s \$0-w_size;
#X obj 102 104 pack2;
#X obj 230 163 initmess \; \$0-set-window 5 \; \$0-overlap-set 4;
#X connect 1 0 0 0;
#X connect 4 0 7 0;
#X connect 4 0 2 0;
#X connect 4 0 6 0;
#X connect 5 0 7 1;
#X connect 5 0 3 0;
#X connect 7 0 1 0;
#X coords 0 0 1 1 120 60 0;
#X restore 389 436 pd Window;
#X obj 462 433 nbx 2 14 1 1e+37 0 1 \$0-overlap \$0-overlap-set empty
0 -8 0 10 -228856 -1 -1 4 256;
#X text 493 432 overlaps;
#X obj 238 398 out~;
#N canvas 385 106 731 354 filter-table 0;
#X obj 95 153 phasor~;
#X obj 231 93 r \$0-w_size;
#X msg 241 159 set \$1;
#X obj 241 183 block~;
#X msg 231 205 resize \$1;
#X obj 231 123 / 2;
#X obj 67 62 inlet;
#X obj 95 127 blocksize~ -hz;
#X obj 66 224 tabsend~ \$0-filter;
#X obj 231 228 s \$0-filter;
#X obj 73 264 table \$0-filter;
#X text 348 125 With the output of [function~] \, we generate a filter
table via [tabsend~]. The window size needs to be half of the actual
FFT cause we're using [rfft~] and only need frequency points up to
Nyquist., f 46;
#X obj 66 192 function~;
#X connect 0 0 12 0;
#X connect 1 0 5 0;
#X connect 2 0 3 0;
#X connect 4 0 9 0;
#X connect 5 0 4 0;
#X connect 5 0 2 0;
#X connect 6 0 12 0;
#X connect 7 0 0 0;
#X connect 12 0 8 0;
#X coords 0 354 1 353 514 130 0;
#X restore 85 320 pd filter-table;
#N canvas 641 138 411 401 filter 0;
#X obj 80 32 inlet~;
#X obj 80 107 rfft~;
#X obj 80 204 rifft~;
#X obj 80 317 outlet~;
#X obj 191 202 block~;
#X obj 191 175 r \$0-set-block;
#X obj 80 160 *~;
#X obj 119 160 *~;
#X obj 80 78 hann~;
#X obj 80 247 hann~;
#X obj 137 124 tabreceive~ \$0-filter;
#X text 271 256 normalization;
#X obj 80 281 *~;
#X obj 137 248 blocksize~;
#X obj 137 280 expr 1 / ($f1 * overlap_\$0 * 0.375);
#X connect 0 0 8 0;
#X connect 1 0 6 0;
#X connect 1 1 7 0;
#X connect 2 0 9 0;
#X connect 5 0 4 0;
#X connect 6 0 2 0;
#X connect 7 0 2 1;
#X connect 8 0 1 0;
#X connect 9 0 12 0;
#X connect 10 0 7 1;
#X connect 10 0 6 1;
#X connect 12 0 3 0;
#X connect 13 0 14 0;
#X connect 14 0 12 1;
#X restore 238 362 pd filter;
#X text 447 408 window size;
#X text 125 78 Here we have a very similar example \, but we use an
envelope generator to generate the filter table. We can also say we're
applying a "Spectral Envelope" into a FFT analysis. Open subpatches
below to see the implementation.;
#X obj 418 29 declare -path else;
#X obj 238 322 play.file~ 1 didge.aif 1 1;
#X obj 85 196 function 200 100 empty empty 0 1 220 220 220 50 50 50
1 0 0 0 1 1 1;
#X text 304 238 <= Click and drag;
#X obj 85 165 initmess 1 1 1;
#X connect 0 0 3 0;
#X connect 1 0 2 0;
#X connect 2 0 0 0;
#X connect 4 0 3 1;
#X connect 8 0 6 0;
#X connect 12 0 8 0;
#X connect 13 0 7 0;
#X connect 15 0 13 0;
