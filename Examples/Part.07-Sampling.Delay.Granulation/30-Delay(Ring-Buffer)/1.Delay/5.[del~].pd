#N canvas 532 23 561 682 12;
#X declare -path else;
#X obj 308 301 nbx 5 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X obj 326 451 nbx 5 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X obj 79 506 out~;
#X obj 308 367 out~;
#X obj 326 517 out~;
#X obj 378 21 declare -path else;
#X obj 79 306 play.file~ bubul.wav 1 1;
#X obj 104 471 del~ in \$0-del 3000;
#X obj 326 481 del~ out \$0-del 1500;
#X msg 104 341 size 1500;
#X msg 117 368 size 3000;
#X msg 132 431 freeze \$1;
#X obj 132 405 tgl 17 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000 0 1;
#X text 155 403 <= freeze;
#X text 32 215 Check the help file for more details. Below \, check how you can resize the delay line and also freeze it. When frozen \, the write head stops writing to the delay line but keeps moving., f 71;
#X text 84 598 Note that this object also has the order of execution issue. But [del~ in] has a dummy signal outlet to help this \, check the example in the help file.;
#X text 32 164 This object also fixes a bug present in [delwrite~] \, [delread~] and [delread4~] when the read and write objects have different block sizes mentioned earlier., f 71;
#X obj 308 331 del~ out -samps \$0-del 22050;
#X text 449 355 same as 500 ms, f 7;
#X text 32 57 The [del~] object from ELSE basically comprises both [delwrite~] and [dlread4~]. This object behaves like [delwrite~] if created as [del~ in] \, and as [delred4~] if created as [del~ out]. It uses a different interpolation method (apline) and offers more functionalitites not present in the native delay objects (at least yet) \, like being able to resize the delay line in [del~ in] and also "freeze" the recording. We can also set the delay time in samples instead of ms., f 71;
#X connect 0 0 17 0;
#X connect 1 0 8 0;
#X connect 6 0 2 0;
#X connect 6 0 7 0;
#X connect 8 0 4 0;
#X connect 9 0 7 0;
#X connect 10 0 7 0;
#X connect 11 0 7 0;
#X connect 12 0 11 0;
#X connect 17 0 3 0;
