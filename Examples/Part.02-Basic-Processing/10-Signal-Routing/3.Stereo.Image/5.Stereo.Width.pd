#N canvas 474 38 634 581 12;
#X declare -path else;
#X obj 370 12 declare -path else;
#X obj 267 273 else/knob 50 -1 1 0 0 empty empty #dfdfdf #7c7c7c black 1 0 0 0 1 320 0 0 0 empty empty 0 12 6 -15 0 1 0 0 0 0;
#X obj 213 325 *~;
#X obj 49 406 else/meter2~;
#X obj 146 277 ms.enc~, f 10;
#X obj 146 363 ms.dec~, f 10;
#X obj 127 225 play.file~ stereo.wav 1 1;
#X obj 267 339 f2s~ 10;
#X text 23 57 There are many techniques for recording stereo. One of each uses a figure 8 mic to pick the "sides" and a directional one to the the "center". Then you have two signals that enconce the "mid" and the "sides" and you need to decode it into stereo (Left and Right). Conversely \, one can also take a regular stereo signal and decode it into mid/side signals., f 73;
#X obj 146 424 out~;
#X obj 267 372 numbox~ 6 12 100 #C0C0C4 #440008 10 0 0 0;
#X floatatom 471 423 9 0 0 0 - - - 0;
#X obj 393 388 osc~ 440;
#X obj 373 358 noise~;
#X obj 471 366 else/knob 50 -1 1 0 1 empty empty #dfdfdf #7c7c7c black 1 0 0 0 1 320 0 0 0 empty empty 0 12 6 -15 0 1 0 0 0 0;
#X obj 471 447 f2s~ 10;
#X obj 328 474 out~;
#X obj 374 426 width~;
#X text 23 142 ELSE has [ms.enc~] and [ms.dec~] abstractions to encode and decode to and from mid/side. When having access to the side signal \, we can adjust its gain to control the stereo image. Open the abstractions to see how the encoding and decoding work. Check the help files as wel.., f 73;
#X text 351 212 The [width~] object from ELSE is a compiled object that takes a stereo input and directly controls the width in the same way as the example to the left. Inside it has mid/side encoding/decoding., f 26;
#X connect 1 0 7 0;
#X connect 2 0 5 1;
#X connect 4 0 5 0;
#X connect 4 1 2 0;
#X connect 5 0 3 0;
#X connect 5 0 9 0;
#X connect 5 1 3 1;
#X connect 5 1 9 1;
#X connect 6 0 4 0;
#X connect 6 1 4 1;
#X connect 7 0 2 1;
#X connect 7 0 10 0;
#X connect 11 0 15 0;
#X connect 12 0 17 1;
#X connect 13 0 17 0;
#X connect 14 0 11 0;
#X connect 15 0 17 2;
#X connect 17 0 16 0;
#X connect 17 1 16 1;
