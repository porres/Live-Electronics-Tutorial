#N canvas 329 89 905 684 12;
#X obj 518 508 *~;
#X obj 555 554 +~;
#X obj 600 548 *~;
#X obj 461 426 *~;
#X obj 600 475 *~;
#X obj 642 210 expr 1000 / $f1;
#X obj 618 180 nbx 5 14 5 500 0 0 empty \$0-size empty 0 -8 0 10 -228856
-1 -1 75 256;
#X floatatom 642 240 6 0 0 0 - - -;
#X text 719 323 Hz;
#X obj 555 593 out~;
#X obj 536 448 envelope~;
#X obj 744 539 envelope~;
#X obj 464 32 sampler~ ../../../../../samples/bubul.wav 1 1;
#X obj 111 272 *~ 50;
#X msg 73 204 5;
#X msg 148 203 -5;
#X obj 111 241 phasor~;
#X obj 111 340 out~;
#X obj 111 304 delread4~ \$0-buffer;
#X text 60 181 lower;
#X text 178 202 higher;
#X msg 111 203 0;
#X text 109 180 original;
#X text 33 27 We've used delay as sort of a pitch shifter in the arpeggiator
example. When we have an ascending ramp \, the delay time increases
and reading speed slows down. On the other hand \, a downwards ramp
speeds up. For up and down ramps \, we can use a simple [phasor~] object
\, but the relationship is inverted - because a positive frequency
(an ascending ramp) lowers the pitch and a negative frequency (descending
ramp) raises the pitch., f 53;
#X text 33 414 Now we need to calculate the frequency of [phasor~]
from a ratio. First we we need to subtract the reading head speed that's
always running (that'd be subtracting 1). Then we need to invert the
result because of the inverted relationship. This is calculated by
subtracting the ratio from 1 instead. Now that we have the adjusted
ratio/transposition frequency \, we multiply it by the grain size frequency.
, f 53;
#X obj 762 174 nbx 5 14 -1e+37 1e+37 0 0 empty \$0-cents empty 0 -8
0 10 -228856 -1 -1 -400 256;
#X floatatom 762 272 9 0 0 0 - - -;
#X floatatom 762 222 5 0 0 0 - - -;
#X obj 762 197 cents2ratio;
#X obj 762 245 expr 1 - $f1;
#X obj 744 298 *~;
#X obj 744 322 display~;
#X text 691 233 grain freq., f 5;
#X text 623 159 grain size;
#X text 674 178 (ms);
#X text 760 152 transposition;
#X text 821 171 (cents);
#X obj 275 224 initmess \; \$0-size 75 \; \$0-cents -400;
#X obj 461 457 delread4~ \$0-buffer, f 9;
#X obj 600 502 delread4~ \$0-buffer;
#X obj 618 421 f2s~ 50;
#X obj 744 425 pimp~ 0 0.5;
#X obj 536 387 pimp~;
#X obj 491 67 delwrite~ \$0-buffer 500;
#X obj 464 166 pshift~;
#X obj 464 208 out~;
#X obj 487 116 nbx 5 14 -2400 2400 0 0 empty \$0-cents empty 0 -8 0
10 -228856 -1 -1 495 256;
#X text 548 115 transposition;
#X text 34 550 Again \, we have two overlapping grains and we're done.
The grain sizes in this example range from 5 to 200 ms. The grain size
only affects the result if it is too small or too big \, so we usually
have it at a fixed reasonable value. Check how this works to the right
and see the [pshift~] object from ELSE \, which is implemented this
way., f 53;
#X connect 0 0 1 0;
#X connect 1 0 9 0;
#X connect 1 0 9 1;
#X connect 2 0 1 1;
#X connect 3 0 38 0;
#X connect 4 0 39 0;
#X connect 5 0 7 0;
#X connect 6 0 5 0;
#X connect 6 0 40 0;
#X connect 7 0 30 0;
#X connect 10 0 0 1;
#X connect 11 0 2 1;
#X connect 12 0 43 0;
#X connect 12 0 44 0;
#X connect 13 0 18 0;
#X connect 14 0 16 0;
#X connect 15 0 16 0;
#X connect 16 0 13 0;
#X connect 18 0 17 0;
#X connect 18 0 17 1;
#X connect 21 0 16 0;
#X connect 25 0 28 0;
#X connect 26 0 30 1;
#X connect 27 0 29 0;
#X connect 28 0 27 0;
#X connect 29 0 26 0;
#X connect 30 0 31 0;
#X connect 31 0 42 0;
#X connect 31 0 41 0;
#X connect 38 0 0 0;
#X connect 39 0 2 0;
#X connect 40 0 3 1;
#X connect 40 0 4 1;
#X connect 41 0 4 0;
#X connect 41 0 11 0;
#X connect 42 0 3 0;
#X connect 42 0 10 0;
#X connect 44 0 45 0;
#X connect 44 0 45 1;
#X connect 46 0 44 1;
