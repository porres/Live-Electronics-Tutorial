#N canvas 329 62 905 684 12;
#X declare -path else;
#X obj 518 508 *~;
#X obj 555 554 +~;
#X obj 600 548 *~;
#X obj 461 426 *~;
#X obj 600 475 *~;
#X obj 642 210 expr 1000 / $f1;
#X obj 618 180 nbx 5 14 5 500 0 0 empty \$0-size empty 0 -8 0 10 #dcdcdc
#000000 #000000 0 256;
#X floatatom 642 240 6 0 0 0 - - - 0;
#X text 818 326 Hz;
#X obj 555 593 out~;
#X obj 536 448 envelope~;
#X obj 744 539 envelope~;
#X obj 111 272 *~ 50;
#X msg 73 204 5;
#X msg 148 203 -5;
#X obj 111 241 phasor~;
#X obj 111 340 out~;
#X obj 111 304 delread4~ \$0-buffer;
#X text 60 181 lower;
#X text 178 202 higher;
#X msg 111 203 0;
#X text 109 180 original;
#X text 33 414 Now we need to calculate the frequency of [phasor~]
from a ratio. First we we need to subtract the reading head speed that's
always running (that'd be subtracting 1). Then we need to invert the
result because of the inverted relationship. This is calculated by
subtracting the ratio from 1 instead. Now that we have the adjusted
ratio/transposition frequency \, we multiply it by the grain size frequency.
, f 53;
#X obj 762 174 nbx 5 14 -1e+37 1e+37 0 0 empty \$0-cents empty 0 -8
0 10 #dcdcdc #000000 #000000 0 256;
#X floatatom 762 272 9 0 0 0 - - - 0;
#X floatatom 762 222 5 0 0 0 - - - 0;
#X obj 762 197 cents2ratio;
#X obj 762 245 expr 1 - $f1;
#X obj 744 298 *~;
#X text 691 233 grain freq., f 5;
#X text 623 159 grain size;
#X text 674 178 (ms);
#X text 760 152 transposition;
#X text 821 171 (cents);
#X obj 275 224 initmess \; \$0-size 75 \; \$0-cents -400;
#X obj 461 457 delread4~ \$0-buffer, f 9;
#X obj 600 502 delread4~ \$0-buffer;
#X obj 618 421 f2s~ 50;
#X obj 744 425 pimp~ 0 0.5;
#X obj 536 387 pimp~;
#X obj 491 117 delwrite~ \$0-buffer 500;
#X obj 464 248 out~;
#X obj 504 175 nbx 5 14 -2400 2400 0 0 empty \$0-cents empty 0 -8 0
10 #dcdcdc #000000 #000000 0 256;
#X text 497 154 transposition;
#X obj 464 206 pitch.shift~;
#X text 34 550 Again \, we have two overlapping grains and we're done.
The grain sizes in this example range from 5 to 200 ms. The grain size
only affects the result if it is too small or too big \, so we usually
have it at a fixed reasonable value. Check how this works to the right
and see the [pitch.shift~] object from ELSE \, which is implemented
this way., f 53;
#X obj 660 26 declare -path else;
#X obj 464 82 play.file~ bubul.wav 1 1;
#X text 23 28 We've used delay as sort of a pitch shifter in the arpeggiator
example. Remember when we have an ascending ramp \, the delay time
increases and reading speed slows down. On the other hand \, a downwards
ramp speeds up. For up and down ramps \, we can use a simple [phasor~]
object \, but the relationship is inverted - because a positive frequency
(an ascending ramp) lowers the pitch and a negative frequency (descending
ramp) raises the pitch., f 56;
#X obj 744 326 numbox~ 6 12 100 #C0C0C4 #440008 10 0 0 0;
#X connect 0 0 1 0;
#X connect 1 0 9 0;
#X connect 2 0 1 1;
#X connect 3 0 35 0;
#X connect 4 0 36 0;
#X connect 5 0 7 0;
#X connect 6 0 5 0;
#X connect 6 0 37 0;
#X connect 7 0 28 0;
#X connect 10 0 0 1;
#X connect 11 0 2 1;
#X connect 12 0 17 0;
#X connect 13 0 15 0;
#X connect 14 0 15 0;
#X connect 15 0 12 0;
#X connect 17 0 16 0;
#X connect 20 0 15 0;
#X connect 23 0 26 0;
#X connect 24 0 28 1;
#X connect 25 0 27 0;
#X connect 26 0 25 0;
#X connect 27 0 24 0;
#X connect 28 0 49 0;
#X connect 35 0 0 0;
#X connect 36 0 2 0;
#X connect 37 0 3 1;
#X connect 37 0 4 1;
#X connect 38 0 4 0;
#X connect 38 0 11 0;
#X connect 39 0 3 0;
#X connect 39 0 10 0;
#X connect 42 0 44 1;
#X connect 44 0 41 0;
#X connect 47 0 40 0;
#X connect 47 0 44 0;
#X connect 49 0 39 0;
#X connect 49 0 38 0;
