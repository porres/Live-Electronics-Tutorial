#N canvas 684 241 746 603 12;
#X declare -path else;
#X obj 249 339 envelope~;
#X obj 249 307 envgen~;
#X obj 353 293 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 0
1;
#X obj 353 320 switch~;
#X obj 91 450 *~;
#X obj 49 367 mtof;
#X obj 191 219 limit;
#X obj 164 17 inlet;
#X obj 91 487 pan2~, f 10;
#X obj 91 541 outlet~;
#X obj 158 541 outlet~;
#X obj 191 250 t b f b, f 17;
#X msg 249 280 0 \$1 1;
#X obj 164 88 limit 1000 1;
#X obj 340 369 rand.f 0.1 1;
#X obj 157 331 rand.f -1 1;
#X obj 49 398 wavetable~ \$2;
#X obj 249 371 *~ 0;
#X text 92 190 grain size =>;
#X text 332 145 The first randm parameter is the grain size in ms.
This also goes through a second [limit] object \, which now waits until
the grain period is over before sending the last message received in
this period. This is not really useful here \, because of the fixed
parameters we're using \, but it's needed in the abstraction version
provided in ELSE., f 51;
#X text 420 263 The gran size is sent to an [envgen~] \, which generates
the phase of the envelope generated by [envelope~] \, whose right inlet
reports its status and turns this subwindow on and off (this saved
CPU power when off)., f 38;
#X text 496 369 The rest of the parameters are also randomized. These
are: amplitude \, pan and pitch., f 27;
#X text 261 490 This patch is used inside [clone] in one of the examples.
;
#X obj 237 16 inlet;
#X text 332 68 The [limit] object is first used to ignore triggers
received within the cloud event period (1 second). Then \, the trigger
is delayed a random time for each grain (in asynchronous mode) or delayed
at equal steps (for synchronous mode)., f 51;
#N canvas 535 153 1005 445 mode 0;
#X obj 180 71 inlet;
#X obj 304 362 outlet;
#X obj 212 277 random 1000;
#X obj 180 248 t b b;
#X obj 247 71 inlet;
#X obj 304 277 delay;
#X floatatom 437 243 5 0 0 0 - - -;
#X obj 286 166 loadbang;
#X obj 180 277 del;
#X obj 247 100 vradio 17 1 0 2 empty empty empty 0 -8 0 10 -228856
-1 -1 0;
#X text 353 276 <= synchronous;
#X text 271 116 synchronous, f 12;
#X text 271 99 asynchronous;
#X text 69 263 asynchronous =>;
#X text 513 110 In this subpatch we deal with the time interval between
grains. For the asynchronous mode \, these are randomized \, so we
have [random] giving us random attack values within an event duration
(1000 ms). But one instance is made sure to be triggered with no delay
and that is instance "0" \, which gets no random range. For that we
check if the instance number is not zero \, if not \, then the random
range is 1000!, f 49;
#X obj 286 195 expr (\$1 != 0) * 1000 \; \$1 * (1000./16);
#X text 513 245 For the synchronous mode \, the grains are equally
spaced. So we get the time interval by divding the event length (1000ms)
by the number of instances (16) \, then we multiply byt the instance
number so each one is placed in the correct spot., f 49;
#X obj 180 196 router;
#X connect 0 0 17 0;
#X connect 2 0 8 1;
#X connect 3 0 8 0;
#X connect 3 1 2 0;
#X connect 4 0 9 0;
#X connect 5 0 1 0;
#X connect 6 0 5 1;
#X connect 7 0 15 0;
#X connect 8 0 1 0;
#X connect 9 0 17 1;
#X connect 15 0 2 1;
#X connect 15 1 6 0;
#X connect 17 0 3 0;
#X connect 17 1 5 0;
#X restore 191 134 pd mode;
#X text 73 133 asynchronous ==> or synchronous, f 16;
#X obj 191 188 rand.f 10 50;
#X obj 49 331 rand.f 40 80;
#X obj 531 37 declare -path else;
#X connect 0 0 17 0;
#X connect 1 0 0 0;
#X connect 1 1 2 0;
#X connect 2 0 3 0;
#X connect 4 0 8 0;
#X connect 5 0 16 0;
#X connect 6 0 11 0;
#X connect 7 0 13 0;
#X connect 8 0 9 0;
#X connect 8 1 10 0;
#X connect 11 0 15 0;
#X connect 11 0 28 0;
#X connect 11 1 6 1;
#X connect 11 1 12 0;
#X connect 11 2 14 0;
#X connect 12 0 1 0;
#X connect 13 0 25 0;
#X connect 14 0 17 1;
#X connect 15 0 8 1;
#X connect 16 0 4 0;
#X connect 17 0 4 1;
#X connect 23 0 25 1;
#X connect 25 0 27 0;
#X connect 27 0 6 0;
#X connect 28 0 5 0;
