#N canvas 251 44 1168 821 12;
#X declare -path else;
#X obj 538 232 setdsp~;
#X obj 880 17 declare -path else;
#X obj 291 283 graph~ 10000 3 0 1 200 140 #dfdfdf 0 1;
#X obj 291 168 pulse~ 4;
#X obj 691 441 pulse~ 4;
#X obj 908 648 graph~ 10000 3 -0.025 1.025 200 140;
#X obj 988 446 v delta;
#X floatatom 723 165 5 10 125 0 - - - 0;
#X text 765 165 ms;
#X floatatom 383 199 4 0 0 0 - - - 0;
#X obj 383 173 expr 1000./$f1;
#X floatatom 383 147 5 10 125 0 - \$0-ms - 0;
#X text 422 146 ms;
#X obj 542 611 v sr_khz;
#X obj 404 522 v a;
#X obj 291 238 lop~;
#X text 415 200 hz;
#X obj 383 224 hz2rad;
#X obj 383 250 v k;
#X obj 61 238 fexpr~ $x * k + (1 - k) * $y;
#X obj 61 283 graph~ 10000 3 0 1 200 140 #dfdfdf 0 1;
#X obj 311 648 graph~ 10000 3 0 1 200 140 #dfdfdf 0 1;
#X obj 81 534 pulse~ 4;
#X floatatom 311 526 5 10 125 0 - \$0-ms - 0;
#X text 350 526 ms;
#X obj 81 648 graph~ 10000 3 0 1 200 140 #dfdfdf 0 1;
#X obj 311 553 expr a = exp(log(0.001) / ($f1 * sr_khz));
#X obj 542 586 sr~ -khz;
#X obj 723 135 initmess 25;
#X floatatom 723 315 5 10 125 0 - - - 0;
#X text 765 315 ms;
#X obj 723 285 initmess 125;
#X text 30 13 A 'lag filter' is a non linear ramp to smoothen signal changes and is implemented with a one pole filter \, wich is what's inside the [lag~] object from ELSE (and also in other ELSE objects like [decay~] and [adsr~]). But first let's use [lop~]! We want a lag time in ms \, so convert it to cutoff frequency. Below we have [pulse~] at 4 hz \, which alternates between 0 and 1 at double the rate (so 8 hz). The period of 8 hz is 125 ms \, so we use it as the lag time. The [lop~] filter was explained in detail and it was also shown how to implement it with [rpole~] and [fexpr~]. Below we also present the [fexpr~] version \, whose coefficient is the cutoff frequency in radians per sample., f 83;
#X text 60 449 Let's look at [lag~] and its formula now \, which is a bit different. The filter coefficient is calculated from a period input in 'ms' and is multiplied by a difference between the filter's last output and its input., f 78;
#X obj 524 167 initmess \; \$0-ms 125;
#X obj 311 602 fexpr~ $x + a * ($y - $x);
#X obj 691 601 lag2~;
#X obj 691 648 graph~ 10000 3 -0.025 1.025 200 140;
#X obj 81 602 lag~;
#X obj 707 543 r f_up;
#X obj 723 574 r f_down;
#X obj 919 446 v a_down;
#X obj 737 342 s f_down;
#X obj 723 370 expr a_down = exp(log(0.001) / ($f1 * sr_khz));
#X obj 723 223 expr a_up = exp(log(0.001) / ($f1 * sr_khz));
#X obj 738 194 s f_up;
#X obj 862 446 v a_up;
#X obj 708 486 fexpr~ delta = $y2 - $x \; $x + if(delta < 0 \, a_up * delta \, a_down * delta);
#X text 696 62 The [lag2~] has a distinct time for up and down lag. Below we can see how to implement that with [fexpr~]., f 48;
#X text 829 118 As for the formula coefficient \, you may realize it is quite similar to the formula that converts 'T60' to filter coefficient from [comb.filt~] presented before., f 36;
#X text 833 280 The input time is the lag time in ms for how long it takes for the signal to converge to within 0.01% of the target value., f 39;
#X connect 3 0 15 0;
#X connect 3 0 19 0;
#X connect 4 0 36 0;
#X connect 4 0 47 0;
#X connect 7 0 44 0;
#X connect 7 0 45 0;
#X connect 9 0 15 1;
#X connect 9 0 17 0;
#X connect 10 0 9 0;
#X connect 11 0 10 0;
#X connect 15 0 2 0;
#X connect 17 0 18 0;
#X connect 19 0 20 0;
#X connect 22 0 35 0;
#X connect 22 0 38 0;
#X connect 23 0 26 0;
#X connect 23 0 38 1;
#X connect 27 0 13 0;
#X connect 28 0 7 0;
#X connect 29 0 42 0;
#X connect 29 0 43 0;
#X connect 31 0 29 0;
#X connect 35 0 21 0;
#X connect 36 0 37 0;
#X connect 38 0 25 0;
#X connect 39 0 36 1;
#X connect 40 0 36 2;
#X connect 47 1 5 0;
