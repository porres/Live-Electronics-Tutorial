#N canvas 336 50 864 532 12;
#X declare -path else;
#X floatatom 536 215 11 0 0 0 - - - 0;
#X floatatom 536 103 8 0 0 0 - - - 0;
#X obj 539 71 hsl 200 19 0 7 0 0 empty slider empty -2 -8 0 10 #dcdcdc #000000 #000000 0 0;
#X obj 536 189 tabread4 lagrange;
#N canvas 316 50 432 348 tabread_larange 0;
#X obj 71 114 t b f;
#X obj 251 217 v frac;
#X obj 136 217 v a;
#X obj 164 217 v b;
#X obj 193 217 v c;
#X obj 222 217 v d;
#X obj 300 189 v i;
#X obj 136 121 expr lagrange[i - 1] \; lagrange[i] \; lagrange[i + 1] \; lagrange[i + 2] \; $f1 - i \; int($f1);
#X obj 144 97 s index;
#X obj 136 72 clip 1 6;
#X obj 71 22 inlet;
#X obj 72 298 outlet;
#X obj 72 252 expr b + frac * (c - b - 0.5 / 3 * (1-frac) * ((d - a - 3*(c-b)) * frac + (d + 2*a - 3*b))), f 45;
#X connect 0 0 12 0;
#X connect 0 1 9 0;
#X connect 7 0 2 0;
#X connect 7 1 3 0;
#X connect 7 2 4 0;
#X connect 7 3 5 0;
#X connect 7 4 1 0;
#X connect 7 5 6 0;
#X connect 9 0 8 0;
#X connect 9 0 7 0;
#X connect 10 0 0 0;
#X connect 12 0 11 0;
#X restore 554 133 pd tabread_larange;
#X floatatom 554 160 11 0 0 0 - - value4 0;
#X obj 526 267 cnv 15 198 198 empty empty empty 20 12 0 14 #d0d0d0 #404040 0;
#X obj 550 267 cnv 15 124 198 empty \$0-dot . -11 97 0 40 #f0f0f0 #fc0400 0;
#X text 531 464 |;
#X text 658 464 |;
#X text 555 474 |;
#X text 682 474 |;
#X text 555 470 |;
#X text 555 464 |;
#X text 682 470 |;
#X text 682 465 |;
#X text 709 474 |;
#X text 709 470 |;
#X text 709 465 |;
#X text 582 474 |;
#X text 582 470 |;
#X text 582 464 |;
#X text 489 483 0 = n-3;
#N canvas 0 22 450 300 (subpatch) 0;
#X array lagrange 8 float 2;
#X coords 0 1 8 -1 200 200 1;
#X restore 525 266 graph;
#X text 491 468 copy:;
#X text 723 467 copies:;
#N canvas 861 296 257 312 plot 0;
#X msg 81 237 label_pos \$2 \$1;
#X obj 135 128 / 7;
#X obj 81 265 s \$0-dot;
#X obj 61 146 * -100;
#X obj 135 103 r index;
#X obj 61 110 r value4;
#X obj 61 173 + 87;
#X obj 134 182 - 37;
#X obj 134 154 * 176;
#X obj 54 27 initmess \; lagrange 0 0.9 -0.1 -0.5 0.3 0.6 0.9 -0.1 -0.5, f 24;
#X obj 81 211 pack f f;
#X connect 0 0 2 0;
#X connect 1 0 8 0;
#X connect 3 0 6 0;
#X connect 4 0 1 0;
#X connect 5 0 3 0;
#X connect 6 0 10 0;
#X connect 7 0 10 1;
#X connect 8 0 7 0;
#X connect 10 0 0 0;
#X restore 672 247 pd plot;
#X text 559 474 ______________________;
#X text 28 191 The index 0 needs to be a copy of the last actual index (5 or "n-3") \, whereas the last two (n-2 & n-1 \, "6" and "7" in this case) need to be copies of the first two (respectively \, index "1" and "2").;
#X obj 672 31 declare -path else;
#X text 28 254 Being 'circular' means that is possible to "loop" between the indexes 1 and n-2 ("6"). Thus \, when you reach index 6 it is the same as index 1 \, and in between index 5 and 6 the method looks ahead 2 points that are copies of the first two. On the other hand \, when in between index 1 and 2 \, it looks 2 points back and needs a copy of the last index (5).;
#X text 727 482 n-2 (6) = 1;
#X text 728 495 n-1 (7) = 2;
#X text 28 425 The [tabread4] object and other similar objects in Pd Vanilla ignore the indexes for the guard points (0 \, 6 and 7). Hence \, input values are clipped to 1 and 6 Check the [pd lagrange] subpatch \, which calculates the interpolation. You can compare the result with the output of [tabread4] to see how they match.;
#X text 28 87 In this example we have 8 points (n = 8) \, where indexes are from 0 to 7 \, but the table is considered to be "circular" \, which means it ends where it starts. Because we need extra points for interpolation \, the actual indexes are from 1 to 5! The first (0) and last two (6-7) are the extra points (also called "guard points") that are needed for Vanilla's objects.., f 60;
#X text 28 23 The Pd native objects [tabread4] \, [tabread4~] \, [tabosc4~] and [delread4~] use a 4-point cubic polynomial method called "lagrange". When calculating a fractional index value \, it considers 2 points ahead and 2 points behind.;
#X text 29 344 The array to the right is set to display in "points" \, but since it is quite a small table \, we see lines rather than points. The actual "points" would be in the beginning of the lines. Anyway \, move the slider and see the interpolation result as the red dot's position.;
#X text 535 464 __________________;
#X text 723 118 See below an example on how to use [phasor~] and [tabdrea4~], f 16;
#N canvas 383 122 920 426 phasor~ 0;
#X obj 566 229 cnv 15 248 138 empty empty empty 20 12 0 14 #dcdcdc #404040 0;
#N canvas 0 22 474 324 (subpatch) 0;
#X array \$0-wavetable 1027 float 0;
#X coords 0 1 1026 -1 250 140 1 0 0;
#X restore 565 228 graph;
#X obj 101 232 nbx 4 18 -1e+37 1e+37 0 1 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 100 256;
#X text 547 222 1;
#X text 543 357 -1;
#X obj 101 305 out~;
#X text 154 232 Hz;
#X obj 577 156 send \$0-wavetable;
#X obj 101 265 tabosc4~ \$0-wavetable;
#X msg 577 120 sinesum 1024 1 0.5 0.333 0.25 0.2 \, normalize;
#X obj 577 90 loadbang;
#X obj 348 162 phasor~ 100;
#X obj 348 236 +~ 1;
#X obj 348 321 out~;
#X obj 348 276 tabread4~ \$0-wavetable;
#X msg 101 204 100;
#X obj 101 176 loadbang;
#X text 59 22 The examples below are equivalent. Instead of [tabosc4~] you could use [tabread4~] with [phasor~]. This would be required if you wanted to have phase access in a wavetable synthesizer (for phase modulation) with Pd Vanilla objects only. Because of the guard points \, you need to multiply the output of [phasor~] to a range with only valid indexes \, from 1 to N-2. The table size is "1024" here and the guard points are automatically created with sinesum \, so it has 1027 points. Valid points are from 1 to 1025 (so we multiply by 1024 and add 1)., f 63;
#X obj 348 196 *~ 1024;
#X text 548 31 Of course you can just use [wavetable~] from ELSE if you need phase modulation with wave tables., f 49;
#X connect 2 0 8 0;
#X connect 8 0 5 0;
#X connect 9 0 7 0;
#X connect 10 0 9 0;
#X connect 11 0 18 0;
#X connect 12 0 14 0;
#X connect 14 0 13 0;
#X connect 15 0 2 0;
#X connect 16 0 15 0;
#X connect 18 0 12 0;
#X restore 744 189 pd phasor~ tabread4~;
#X f 10;
#X connect 1 0 3 0;
#X connect 1 0 4 0;
#X connect 2 0 1 0;
#X connect 3 0 0 0;
#X connect 4 0 5 0;
