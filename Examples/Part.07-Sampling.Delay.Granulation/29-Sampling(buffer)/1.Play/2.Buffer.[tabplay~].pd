#N canvas 324 75 930 777 12;
#X declare -path else;
#X obj 620 284 tabplay~ \$0-sample;
#X obj 55 244 soundfiler;
#X floatatom 55 268 0 0 0 0 - - - 0;
#X obj 292 271 soundfiler;
#X floatatom 292 297 0 0 0 0 - - - 0;
#X obj 292 195 openpanel;
#X obj 292 163 bng 20 250 50 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000;
#X obj 620 195 bng 20 250 50 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000;
#X obj 639 237 nbx 4 16 0 1e+37 0 0 empty empty empty 0 -8 0 13 #dcdcdc #000000 #000000 0 256;
#X obj 38 394 cnv 15 438 148 empty empty empty 20 12 0 14 #e0e0e0 #404040 0;
#N canvas 0 22 450 300 (subpatch) 0;
#X array \$0-sample 62079 float 2;
#X coords 0 1 62079 -1 440 150 1 0 0;
#X restore 37 393 graph;
#X obj 729 180 metro 1000;
#X obj 729 208 random;
#X obj 729 152 tgl 19 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000 0 1;
#X text 585 194 play;
#X floatatom 729 231 0 0 0 0 - - - 0;
#X msg 729 253 \$1 44100;
#X obj 292 218 list append \$0-sample;
#X msg 572 236 stop;
#X msg 292 243 read -resize \$1 \$2;
#X obj 620 317 out~;
#X text 102 270 # of samples;
#X text 315 164 choose sound file;
#X obj 55 292 s \$0-size;
#X obj 292 323 s \$0-size;
#X obj 785 207 r \$0-size;
#X text 168 371 Array (or "buffer") with loaded sound file:;
#X text 519 61 The simplest way of playing from an array in Pd Vanilla is with [tabplay~]. A bang plays the whole buffer \, but you can set a start point with a float or a start point and a number of samples to play from it as a list. Check help file for more details., f 52;
#X text 544 395 This is already more flexible as it allows you to play parts and snippets (or even "grains" in a granular perspective)., f 47;
#X obj 694 501 table;
#X obj 754 500 array;
#X text 40 22 For more playing flexibility \, we need to store the file in a "buffer" (term that indicates allocated memory). For such \, we load the file in an array with the native [soundfiler] object \, which needs a "read" message followed by a sound file. The -resize flag resizes the table according to the sound file's number of samples \, which is given in the left outlet (right outlet sends more information like number of channels and sample rate). Check help file for more details., f 61;
#X obj 714 21 declare -path else;
#X text 544 453 You can also use the native [table] or [array] objects to create an array - check their help files., f 47;
#X obj 321 615 sfload \$0-sample;
#X msg 321 579 load guitar.mp3;
#X text 441 579 <-- click to load, f 9;
#X listbox 321 645 26 0 0 0 - - - 0;
#X obj 55 188 initmess read -resize voice.wav \$0-sample, f 21;
#X obj 321 670 /;
#X floatatom 321 696 8 0 0 0 - - - 0;
#X text 392 697 duration in seconds;
#X obj 640 684 sfinfo;
#X msg 640 655 read loop.aif \, channels;
#X obj 640 714 display;
#X text 45 575 [sfload] from ELSE is similar to [soundfiler] but supports more audio formats \, they are: MP3 \, FLAC \, WAV \, AIF \, AAC \, OGG & OPUS. Another difference to [soundfiler] is that it resizes the array by default. While you can use [soundfiler] to just output sample information without loading files \, [sfload] only outputs information if and after loading samples into buffers., f 35;
#X text 698 681 <-- check its help file;
#X text 731 702 for more details.;
#X text 542 552 The [sfinfo] object from ELSE is solely dedicated to query and output sample information. So far it's still experimental and can get number of channels for the same formats as [sfload] supports and also 'inst' metadata from .aif files (needed for sample based synths as we'll see later)., f 51;
#X connect 0 0 20 0;
#X connect 1 0 2 0;
#X connect 2 0 23 0;
#X connect 3 0 4 0;
#X connect 4 0 24 0;
#X connect 5 0 17 0;
#X connect 6 0 5 0;
#X connect 7 0 0 0;
#X connect 8 0 0 0;
#X connect 11 0 12 0;
#X connect 12 0 15 0;
#X connect 13 0 11 0;
#X connect 15 0 16 0;
#X connect 16 0 0 0;
#X connect 17 0 19 0;
#X connect 18 0 0 0;
#X connect 19 0 3 0;
#X connect 25 0 12 1;
#X connect 34 0 37 0;
#X connect 35 0 34 0;
#X connect 37 0 39 0;
#X connect 38 0 1 0;
#X connect 39 0 40 0;
#X connect 42 0 44 0;
#X connect 43 0 42 0;
