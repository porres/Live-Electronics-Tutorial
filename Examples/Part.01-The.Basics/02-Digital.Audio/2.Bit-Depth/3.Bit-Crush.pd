#N canvas 355 43 960 705 12;
#X declare -path else;
#X obj 52 398 graph~ 230 48;
#X obj 150 264 hsl 128 15 0 1 0 0 empty empty empty -2 -8 0 10 #dcdcdc #000000 #000000 0 1;
#X text 29 530 -1;
#X text 34 460 0;
#X text 34 394 1;
#X obj 52 299 quantizer~ 0.1;
#X obj 369 289 display;
#X obj 369 320 / 2;
#X obj 369 346 display;
#X obj 369 239 nbx 3 16 1 16 0 0 empty empty empty 0 -8 0 11 #dcdcdc #000000 #000000 0 256;
#X msg 369 204 8;
#X msg 335 204 16;
#X obj 65 337 out~;
#X obj 52 267 osc~ 440;
#X msg 404 204 4;
#X text 417 240 bits;
#X floatatom 682 254 8 1 10000 0 - - - 0;
#X obj 685 233 hsl 128 15 0 1 0 0 empty empty empty -2 -8 0 10 #dcdcdc #000000 #000000 0 1;
#X obj 750 265 hsl 128 15 0 1 0 0 empty empty empty -2 -8 0 10 #dcdcdc #000000 #000000 0 1;
#X obj 676 322 out~;
#X obj 655 388 graph~ 143 50;
#X obj 656 288 crusher~;
#X obj 369 264 expr pow(2 \, $f1);
#X text 705 231 crush (0-1);
#X text 762 264 decimate (0-1);
#X obj 739 34 declare -path else;
#X text 21 29 With a simple rounding process \, we can simulate a bit depth reduction. This adds noise and reduces the dynamic range and is known as a "bit-crusher" effect \, used as a type of distortion., f 64;
#X obj 369 378 s \$0-steps;
#X obj 147 202 expr 1 / $f1;
#X obj 147 230 display;
#X obj 147 174 r \$0-steps;
#X obj 477 473 r \$0-steps;
#X obj 319 500 expr~ rint($v1*$f2)/$f2;
#X text 336 428 And here's how to perform one type of signal rounding with [expr~]:, f 27;
#X text 21 80 The [quantizer~] object \, from ELSE \, performs different types of rounding (check its help file) and can be used for this (it is also multichannel aware \, check its help file). It receives a step value and rounds to multiples of it. In this example \, we find a step value according to a bit depth resolution., f 64;
#X obj 656 193 else/play.file~ bubul.mp3 1 1;
#X obj 432 589 expr~ trunc($v1);
#X obj 432 616 expr~ floor($v1);
#X obj 432 643 expr~ ceil($v1);
#X text 42 571 There are other ways to round and quantize the amplitudes. the default mode in [quantizer~] is 'rint' \, where it rounds to the nearest. But check the help file for more modes \, like truncate \, floor \, ceil and both floor (for negative values) and ceil (for positive). Note that these functions are also available in [expr]., f 51;
#X obj 369 177 loadbang;
#X floatatom 747 286 8 1 10000 0 - - - 0;
#X text 613 69 The [crusher~] external from ELSE is an abstraction based on [quantizer~] and [downsample~] \, so it combines both processes \, because it is common that a Bit Crushing effect is used in conjunction with decimation and vice versa., f 37;
#X text 594 573 The parameters vary from 0 to 1 \, where 0 is the original sound and the higher the parameter is \, the more crushing/decimation we have. The bit crushing mode in [quantizer~] is "mode 4" \, where it operates with 'floor' for negative values and 'ceil' for positive amplitudes., f 47;
#X connect 1 0 5 1;
#X connect 5 0 0 0;
#X connect 5 0 12 0;
#X connect 6 0 7 0;
#X connect 7 0 8 0;
#X connect 8 0 27 0;
#X connect 9 0 22 0;
#X connect 10 0 9 0;
#X connect 11 0 9 0;
#X connect 13 0 5 0;
#X connect 14 0 9 0;
#X connect 16 0 21 1;
#X connect 17 0 16 0;
#X connect 18 0 41 0;
#X connect 21 0 19 0;
#X connect 21 0 20 0;
#X connect 22 0 6 0;
#X connect 28 0 29 0;
#X connect 29 0 1 0;
#X connect 30 0 28 0;
#X connect 31 0 32 1;
#X connect 35 0 21 0;
#X connect 40 0 10 0;
#X connect 41 0 21 2;
