#N canvas 283 38 1053 846 12;
#X obj 171 383 hz2rad;
#X obj 544 383 hz2rad;
#X obj 164 325 hsl 162 19 0 7020 0 0 empty empty empty -2 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X floatatom 161 355 9 0 0 0 - - - 0;
#X obj 351 383 hz2rad;
#X obj 544 412 clip 0 1;
#X obj 351 412 clip 0 1;
#X obj 171 412 clip 0 1;
#X floatatom 544 355 9 0 0 0 - - - 0;
#X floatatom 351 355 9 0 0 0 - - - 0;
#X obj 729 420 hsl 162 19 0 2 0 0 empty empty empty -2 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X floatatom 726 450 9 0 0 0 - - - 0;
#X obj 730 325 hsl 162 19 0 2 0 0 empty empty empty -2 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X floatatom 727 355 9 0 0 0 - - - 0;
#X obj 376 538 noise~;
#X obj 870 648 out~;
#X obj 547 325 hsl 162 19 0 7020 0 0 empty empty empty -2 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X obj 354 325 hsl 162 19 0 7020 0 0 empty empty empty -2 -10 0 12 #dfdfdf #000000 #000000 0 1;
#X text 67 26 The [slop~] object is very maleable and can be configured in different ways. It can be a slew limiter \, a linear low-pass filter or various other things. The name tries to convey that its identity is in the eye o the beholder. Miller's intention was to design the most flexible nonlinear one-pole filter he could., f 61;
#X obj 376 580 fexpr~ delta = $x - $y2 \; $y2 + if(delta > slew_up \, f_up * (delta - slew_up) + f * slew_up \, if(delta < -slew_down \, f_down * (delta + slew_down) - f * slew_down \, f * delta)), f 71;
#X text 550 28 The 'f' parameter is a cutoff frequency \, 'f_up' is a cutoff frequency for when the signal is rising \, f_down when decreasing. The 'slew_up' is the amplitude limit when the signal is rising and 'slew_down' when decreasing. The 'delta' is the difference between the input and last output (x[0] - y[-1])., f 60;
#X text 198 248 y[n] = y[-1] + if(delta > slew_up \, f_up * (delta - slew_up) + f * slew_up \, if(delta < -slew_down \, f_down * (delta + slew_down) - f * slew_down \, f * delta)), f 80;
#X obj 141 607 slop~, f 13;
#X obj 542 546 v f;
#X obj 644 546 v f_up;
#X obj 578 546 v f_down;
#X obj 785 546 v slew_up;
#X obj 699 546 v slew_down;
#X obj 171 440 s f;
#X obj 544 437 s f_up;
#X obj 351 436 s f_down;
#X obj 726 476 s slew_up;
#X obj 727 382 s slew_down;
#X obj 97 528 noise~;
#X obj 141 642 out~;
#X obj 289 487 r slew_up;
#X obj 177 487 r slew_down;
#X text 401 663 The above is a full implementation of [slop~] in [fexpr~] and in the next examples we'll see simplifications and main combinations.;
#X obj 911 591 v delta;
#X text 274 746 Try changing 'f' when slew parameters are at highest \, and change 'f_down' and 'f_up' when slew parameters are at the lowest. You'll hear the main ways this filter can be used as a one pole filter. More details in the next examples., f 80;
#X text 67 117 This object was used in this tutorial to implement slew limiting \, lag portamentos as well as non linear envelopes. The 3rd and 5th inlet were used to set the slew limiting \, while the 4th and 6th controlled filtering., f 61;
#X text 67 180 In this subsection we'll check it out throughly \, here's the full filter's formula (in a similar way that you'd write into an [fexpr~] object as shown below):, f 61;
#X text 550 128 In short \, if delta is greater than up/down slew limits \, we have a formula that involes f_up/f_down and slew_up/down parameters. If not \, then we just have 'f'. Similar to [lop~] \, these frequencies are in radians per sample but clipped to one \, so maximum cutoff is about 7.02 Khz in a 44.1 Khz sample rate.;
#X connect 0 0 7 0;
#X connect 1 0 5 0;
#X connect 2 0 3 0;
#X connect 3 0 0 0;
#X connect 3 0 22 1;
#X connect 4 0 6 0;
#X connect 5 0 29 0;
#X connect 6 0 30 0;
#X connect 7 0 28 0;
#X connect 8 0 1 0;
#X connect 8 0 22 5;
#X connect 9 0 4 0;
#X connect 9 0 22 3;
#X connect 10 0 11 0;
#X connect 11 0 31 0;
#X connect 12 0 13 0;
#X connect 13 0 32 0;
#X connect 14 0 19 0;
#X connect 16 0 8 0;
#X connect 17 0 9 0;
#X connect 19 1 15 0;
#X connect 22 0 34 0;
#X connect 33 0 22 0;
#X connect 35 0 22 4;
#X connect 36 0 22 2;
