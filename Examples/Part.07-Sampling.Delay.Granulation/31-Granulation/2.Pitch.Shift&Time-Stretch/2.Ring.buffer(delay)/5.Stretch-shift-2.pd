#N canvas 699 72 586 517 12;
#X declare -path else;
#X text 291 305 cents;
#X obj 273 327 nbx 5 16 -1e+37 1e+37 0 0 empty \$0-cents empty 0 -8
0 13 #dcdcdc #000000 #000000 0 256;
#X obj 211 326 nbx 4 16 -1e+37 1e+37 0 0 empty \$0-speed empty 0 -8
0 13 #dcdcdc #000000 #000000 0 256;
#X obj 346 326 nbx 4 16 64 8192 0 0 empty \$0-block empty 0 -8 0 13
#dcdcdc #000000 #000000 0 256;
#X msg 360 210 512;
#X msg 383 276 1024;
#X msg 374 233 2048;
#X msg 346 186 8192;
#X msg 378 255 4096;
#X obj 149 406 out~;
#X text 369 307 size;
#X text 218 306 speed;
#N canvas 251 23 1115 723 pitch-shift/time-stretch 0;
#X obj 266 262 bang~;
#X obj 338 251 nbx 8 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10
#c4fcfc #000000 #000000 0 256;
#X obj 367 700 outlet~;
#X obj 338 39 inlet;
#X obj 569 39 inlet;
#X msg 588 295 set \$1;
#X obj 450 548 phasor~;
#X obj 454 39 inlet;
#X obj 454 99 nbx 5 18 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 15
#e4ccb4 #000000 #000000 0 256;
#X obj 338 100 nbx 5 18 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 15
#b0e0e0 #000000 #000000 0 256;
#X obj 569 258 nbx 5 18 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 15
#f8f4bc #000000 #000000 0 256;
#X obj 432 619 *~;
#X obj 367 666 +~;
#X obj 588 323 block~;
#X obj 320 280 +;
#X obj 367 638 *~;
#X floatatom 569 575 4 0 0 0 - - - 0;
#X obj 569 514 / 2;
#X floatatom 454 168 0 0 0 0 - - - 0;
#X obj 782 99 loadbang;
#X obj 266 292 f;
#X obj 338 128 / 100;
#X obj 356 479 +~;
#X obj 782 205 s \$0-buf_size;
#X obj 352 278 r \$0-buf_size;
#X obj 799 151 s \$0-buf_ms;
#X obj 395 485 r \$0-buf_ms;
#X obj 454 412 / 2;
#X obj 266 415 pack f f f;
#X obj 354 416 +;
#X text 365 307 loop;
#X obj 320 306 wrap2;
#X obj 266 336 samps2ms;
#X obj 450 520 blocksize~ -hz;
#X obj 450 575 envelope~;
#X obj 356 537 wrap2~;
#X obj 266 552 wrap2~;
#X obj 266 439 envgen~;
#X obj 454 132 cents2ratio;
#X obj 782 179 ms2samps;
#X text 346 74 speed (%);
#X obj 338 222 *;
#X obj 338 193 hot;
#X text 469 76 cents;
#X text 585 232 size;
#X obj 266 361 t f f;
#X obj 472 287 samps2ms;
#X floatatom 454 384 0 0 0 0 - - - 0;
#X obj 454 328 hot;
#X obj 454 357 *;
#X text 388 383 new size;
#X text 374 222 step;
#X obj 454 202 expr 1 - $f1;
#X obj 338 162 expr 1 - $f1;
#X text 694 313 This is pretty straight forward adaptation of the earlier
example. Both speed and transposition ratio now need to account for
the read head speed \, and since we now read from [delread4~] instead
of [tabread4~] \, we need values in ms instead of samples., f 43;
#X text 489 413 overlap;
#X text 597 513 overlap;
#X text 694 416 For the overlapping second grain \, we need to sum
to half the new grain size instead of subtracting because this means
"back' in the buffer., f 43;
#X obj 266 578 del~ out \$0-buffer, f 9;
#X obj 356 560 del~ out \$0-buffer, f 9;
#X obj 217 39 inlet~;
#X text 159 38 dummy;
#X msg 782 126 10000;
#X obj 432 645 ffdelay~ -samps 4096;
#X connect 0 0 20 0;
#X connect 1 0 14 1;
#X connect 3 0 9 0;
#X connect 4 0 10 0;
#X connect 5 0 13 0;
#X connect 6 0 34 0;
#X connect 7 0 8 0;
#X connect 8 0 38 0;
#X connect 9 0 21 0;
#X connect 10 0 5 0;
#X connect 10 0 17 0;
#X connect 10 0 42 1;
#X connect 10 0 46 0;
#X connect 11 0 63 0;
#X connect 12 0 2 0;
#X connect 14 0 31 0;
#X connect 15 0 12 0;
#X connect 16 0 63 1;
#X connect 17 0 16 0;
#X connect 18 0 52 0;
#X connect 19 0 62 0;
#X connect 20 0 14 0;
#X connect 20 0 32 0;
#X connect 21 0 53 0;
#X connect 22 0 35 0;
#X connect 24 0 31 2;
#X connect 26 0 35 2;
#X connect 26 0 36 2;
#X connect 27 0 22 1;
#X connect 28 0 37 0;
#X connect 29 0 28 2;
#X connect 31 0 20 1;
#X connect 32 0 45 0;
#X connect 33 0 6 0;
#X connect 34 0 11 1;
#X connect 34 0 15 1;
#X connect 35 0 59 0;
#X connect 36 0 58 0;
#X connect 37 0 22 0;
#X connect 37 0 36 0;
#X connect 38 0 18 0;
#X connect 39 0 23 0;
#X connect 41 0 1 0;
#X connect 42 0 41 0;
#X connect 42 1 41 1;
#X connect 45 0 28 0;
#X connect 45 1 29 0;
#X connect 46 0 48 1;
#X connect 46 0 28 1;
#X connect 47 0 29 1;
#X connect 47 0 27 0;
#X connect 48 0 49 0;
#X connect 48 1 49 1;
#X connect 49 0 47 0;
#X connect 52 0 48 0;
#X connect 53 0 42 0;
#X connect 58 0 15 0;
#X connect 59 0 11 0;
#X connect 62 0 25 0;
#X connect 62 0 39 0;
#X restore 149 360 pd pitch-shift/time-stretch;
#X obj 400 400 initmess \; \$0-speed 50 \; \$0-cents -400 \; \$0-block
2048;
#X obj 350 26 declare -path else;
#X obj 149 177 play.file~ bubul.wav 1 1;
#X text 87 68 This example now adapts for live input (or delay lines)
an earlier pitch shit / time stretch patch in which the grain size
depends on the block size. As the earlier one \, this is the basis
of a Phase Vocoder example presented later. Open the subpatch for details.
;
#X text 163 249 <= force order of execution, f 14;
#X obj 149 218 del~ in \$0-buffer 10000;
#X connect 1 0 12 2;
#X connect 2 0 12 1;
#X connect 3 0 12 3;
#X connect 4 0 3 0;
#X connect 5 0 3 0;
#X connect 6 0 3 0;
#X connect 7 0 3 0;
#X connect 8 0 3 0;
#X connect 12 0 9 0;
#X connect 15 0 18 0;
#X connect 18 0 12 0;
