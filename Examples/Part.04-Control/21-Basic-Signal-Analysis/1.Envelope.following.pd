#N canvas 589 86 490 518 12;
#X declare -path else;
#X obj 257 282 nbx 8 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X obj 345 280 nbx 8 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X obj 254 27 declare -path else;
#X obj 257 313 vsl 19 162 0 100 0 0 empty empty empty 0 -9 0 12 #dfdfdf #000000 #000000 0 1;
#X obj 257 208 adc~ 1;
#X obj 257 254 env~ 8192;
#X obj 57 278 *~;
#X obj 166 329 meter~;
#X obj 57 238 bl.saw~ 50;
#X obj 57 322 out~;
#X obj 366 423 sigmund~;
#X text 298 335 Another object that reports amplitude analysis like [env~] is [sigmund~] \, which we'll see next., f 20;
#X text 32 68 We've already seen the [env~] object from Pd Vanilla and [rms~] from ELSE that is based on it. The difference is just the output scale. They output RMS amplitude from an audio analysis. This is also known as "envelope following" and we can use this analysis to control parameters in our patches. Another object we can use is [mov.avg~]. Here we use it to control the output level., f 56;
#X obj 166 275 mov.rms~ -lin 4096, f 9;
#X obj 345 253 rms~ -lin;
#X connect 0 0 3 0;
#X connect 4 0 5 0;
#X connect 4 0 13 0;
#X connect 4 0 14 0;
#X connect 5 0 0 0;
#X connect 6 0 9 0;
#X connect 8 0 6 0;
#X connect 13 0 6 1;
#X connect 13 0 7 0;
#X connect 14 0 1 0;
