#N canvas 276 33 869 661 12;
#X declare -path else;
#X obj 120 235 keyboard 17 80 2 4 0 0 empty empty;
#X obj 120 160 bng 18 250 50 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000;
#X obj 56 164 notein;
#X obj 56 195 pack;
#X obj 729 610 poly;
#N canvas 470 55 457 368 random_chords 0;
#X obj 174 309 outlet;
#X obj 62 32 inlet;
#X obj 146 242 makenote;
#X obj 218 139 expr $f1 + random(2 \, 5);
#X obj 218 174 expr $f1 + random(2 \, 5);
#X obj 218 208 expr $f1 + random(2 \, 5);
#X obj 62 66 expr random(60 \, 72) \; random(90 \, 127) \; random(500 \, 1000);
#X obj 174 272 pack;
#X connect 1 0 6 0;
#X connect 2 0 7 0;
#X connect 2 1 7 1;
#X connect 3 0 4 0;
#X connect 3 0 2 0;
#X connect 4 0 5 0;
#X connect 4 0 2 0;
#X connect 5 0 2 0;
#X connect 6 0 2 0;
#X connect 6 0 3 0;
#X connect 6 1 2 1;
#X connect 6 2 2 2;
#X connect 7 0 0 0;
#X restore 120 199 pd random_chords;
#X text 143 160 <= generate random chords if you don't have a controller, f 29;
#X text 268 418 <= click;
#X text 693 586 see also:;
#X obj 120 450 plate.rev~ 50 0.6 0.25 0.8 0.8, f 16;
#X obj 79 25 declare -path else;
#X obj 127 496 out~;
#X text 431 166 The first number argument of clone is the number of instances it loads from an abstraction. The second is the patch file name to load. We included a third argument \, which is equal to the number of instances to make a volume compensation inside the patch., f 56;
#X obj 120 418 clone 4 voice-abs 4;
#X text 431 251 Click on the [clone] object to open the abstraction. Check its help file \, and also check the help file of [voices]. The loaded abstraction (voices-abs.pd) is available in the same folder of this series of examples., f 56;
#N canvas 308 211 308 379 voice1 0;
#X obj 126 282 *~;
#X obj 71 132 mtof;
#X floatatom 71 162 5 0 0 0 - - - 0;
#X obj 71 43 inlet;
#X obj 71 74 unpack;
#X floatatom 144 107 5 0 0 0 - - - 0;
#X floatatom 71 105 5 0 0 0 - - - 0;
#X obj 71 197 bl.saw~;
#X obj 144 244 adsr~ 10 10 0.5 50;
#X obj 126 314 throw~ \$0-voice;
#X connect 0 0 9 0;
#X connect 1 0 2 0;
#X connect 2 0 7 0;
#X connect 3 0 4 0;
#X connect 4 0 6 0;
#X connect 4 1 5 0;
#X connect 5 0 8 0;
#X connect 6 0 1 0;
#X connect 7 0 0 0;
#X connect 8 0 0 1;
#X restore 410 524 pd voice1;
#X obj 609 451 /~ 4;
#X obj 609 485 out~;
#X obj 609 423 catch~ \$0-voice;
#N canvas 308 211 308 379 voice1 0;
#X obj 126 282 *~;
#X obj 71 132 mtof;
#X floatatom 71 162 5 0 0 0 - - - 0;
#X obj 71 43 inlet;
#X obj 71 74 unpack;
#X floatatom 144 107 5 0 0 0 - - - 0;
#X floatatom 71 105 5 0 0 0 - - - 0;
#X obj 71 197 bl.saw~;
#X obj 144 244 adsr~ 10 10 0.5 50;
#X obj 126 314 throw~ \$0-voice;
#X connect 0 0 9 0;
#X connect 1 0 2 0;
#X connect 2 0 7 0;
#X connect 3 0 4 0;
#X connect 4 0 6 0;
#X connect 4 1 5 0;
#X connect 5 0 8 0;
#X connect 6 0 1 0;
#X connect 7 0 0 0;
#X connect 8 0 0 1;
#X restore 439 497 pd voice1;
#N canvas 308 211 308 379 voice1 0;
#X obj 126 282 *~;
#X obj 71 132 mtof;
#X floatatom 71 162 5 0 0 0 - - - 0;
#X obj 71 43 inlet;
#X obj 71 74 unpack;
#X floatatom 144 107 5 0 0 0 - - - 0;
#X floatatom 71 105 5 0 0 0 - - - 0;
#X obj 71 197 bl.saw~;
#X obj 144 244 adsr~ 10 10 0.5 50;
#X obj 126 314 throw~ \$0-voice;
#X connect 0 0 9 0;
#X connect 1 0 2 0;
#X connect 2 0 7 0;
#X connect 3 0 4 0;
#X connect 4 0 6 0;
#X connect 4 1 5 0;
#X connect 5 0 8 0;
#X connect 6 0 1 0;
#X connect 7 0 0 0;
#X connect 8 0 0 1;
#X restore 468 468 pd voice1;
#N canvas 308 211 308 379 voice1 0;
#X obj 126 282 *~;
#X obj 71 132 mtof;
#X floatatom 71 162 5 0 0 0 - - - 0;
#X obj 71 43 inlet;
#X obj 71 74 unpack;
#X floatatom 144 107 5 0 0 0 - - - 0;
#X floatatom 71 105 5 0 0 0 - - - 0;
#X obj 71 197 bl.saw~;
#X obj 144 244 adsr~ 10 10 0.5 50;
#X obj 126 314 throw~ \$0-voice;
#X connect 0 0 9 0;
#X connect 1 0 2 0;
#X connect 2 0 7 0;
#X connect 3 0 4 0;
#X connect 4 0 6 0;
#X connect 4 1 5 0;
#X connect 5 0 8 0;
#X connect 6 0 1 0;
#X connect 7 0 0 0;
#X connect 8 0 0 1;
#X restore 497 440 pd voice1;
#X text 77 584 The second argument is a "voice stealing" flag \, which replaces the last pressed note if you press more notes than it can handle. This object was inspired by Pd's native [poly] object \, but [voices] brings more functionalities and it's more convenient., f 85;
#X text 431 36 The native [clone] object loads an abstraction multiple times \, which is quite useful for polyphony. When [clone] receives list messages \, the first number element is the number of the abstraction \, so it routes the rest of the message to that instance. The [voices] object has a list output by default where the first number is the voice number. The second and third are pitch and velocity \, so you can just directly connect it to [clone]., f 56;
#X obj 410 411 voices -split 4 1;
#X obj 120 371 voices 4;
#X text 41 63 The [voices] object \, from ELSE \, manages polyphony. The first argument is the number of voices it handles. Here we have a 4 voice polyphonic example., f 44;
#X text 431 321 [voices] also has a split mode which routes the outputs the note messages to different outlets. Check the help file for more details., f 56;
#X connect 0 0 24 0;
#X connect 0 0 25 0;
#X connect 1 0 5 0;
#X connect 2 0 3 0;
#X connect 2 1 3 1;
#X connect 3 0 0 0;
#X connect 5 0 0 0;
#X connect 9 0 11 0;
#X connect 9 1 11 1;
#X connect 13 0 9 0;
#X connect 16 0 17 0;
#X connect 18 0 16 0;
#X connect 24 0 15 0;
#X connect 24 1 19 0;
#X connect 24 2 20 0;
#X connect 24 3 21 0;
#X connect 25 0 13 0;
