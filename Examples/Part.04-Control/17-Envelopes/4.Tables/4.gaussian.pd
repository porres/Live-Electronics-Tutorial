#N canvas 284 76 912 474 12;
#X declare -path else;
#X obj 376 278 *~;
#X obj 318 225 osc~ 440;
#X obj 394 170 nbx 5 17 0 2000 0 0 empty empty empty 0 -8 0 12 #dcdcdc #000000 #000000 0 256;
#X obj 355 160 bng 20 250 50 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000;
#X obj 376 305 out~;
#X text 462 169 ms;
#X obj 394 225 envgen~;
#X msg 394 196 0 \$1 1;
#X obj 758 17 declare -path else;
#X text 240 376 1;
#X text 240 437 0;
#X obj 257 381 cnv 15 248 68 empty empty empty 20 12 0 14 #dcdcdc #404040 0;
#N canvas 0 22 450 300 (subpatch) 0;
#X array \$0-gauss 8192 float 0;
#X coords 0 1 8191 0 250 70 1 0 0;
#X restore 256 381 graph;
#X obj 32 276 loop;
#X msg 32 247 8191;
#X obj 32 305 t f f, f 25;
#X obj 32 410 exp;
#X floatatom 32 191 5 0 0 0 - - - 0;
#X obj 32 218 t b f, f 7;
#X obj 35 161 hsl 100 15 0.02 1 1 0 empty empty empty -2 -8 0 10 #dcdcdc #000000 #000000 0 1;
#X obj 78 268 v sigma;
#X obj 32 436 tabwrite \$0-gauss, f 23;
#X text 24 93 Below we generate the gaussian table. The input is fixed from -1 to 1 and we just set the 'sigma' value \, which needs to be below 0.25 so we can use this function as an envelope., f 69;
#X obj 32 364 expr -pow($f1 \, 2) / (2 * pow(sigma \, 2)), f 20;
#X obj 579 249 -~ 0.5;
#X obj 579 221 phasor~ 2;
#X obj 579 312 expr~ exp(-$v1*$v1);
#X obj 662 232 pow 4;
#X obj 665 211 hsl 128 15 0 1 0 0 empty empty empty -2 -8 0 10 #dcdcdc #000000 #000000 0 1;
#X obj 662 280 + 4;
#X obj 662 256 * 296;
#X obj 579 279 *~ 4;
#X obj 742 274 gaussian~;
#X text 729 249 similar to:;
#X obj 191 258 tabgen \$0-gauss;
#X msg 191 231 gauss \$1;
#X obj 194 208 hsl 100 15 0.02 1 1 1 empty empty empty -2 -8 0 10 #dcdcdc #000000 #000000 3300 1;
#X obj 394 252 tabreader~ \$0-gauss;
#X obj 579 352 scope~ 265 87 256 3 128 0 1 0 0 0 0 30 30 30 190 190 190 160 160 160 0 empty;
#X obj 394 142 initmess 500;
#X text 24 14 Gaussian functions are often used in statistics and probabilities but can be also used in computer music for an envelope shape as in this example. The Gaussian function has a "bell curve" shape and is here simplified to take only the 'sigma' parameter that controls the width of the bell (aka 'standard deviation' or 'gaussian RMS width')., f 69;
#X obj 844 218 setdsp~;
#X obj 32 335 rescale -in 0 8191 -1 1;
#X text 181 154 The [tabgen] object can also generate gaussian tables, f 19;
#X text 545 51 Another approach is to have a fixed sigma value and we just change the input range to something other than -1 to 1 \, which also works to change the bell width. Let's take a sigma value of square root of 0.5 (0.707107...) \, this simplifies the equation and makes '(2 * pow(sigma \, 2)' = 1! So the formula is just "exp(-pow($f1 \, 2))". This is how ELSE's [gaussian~] is implemented. See the patch implementation below., f 50;
#X connect 0 0 4 0;
#X connect 1 0 0 0;
#X connect 2 0 7 0;
#X connect 3 0 6 0;
#X connect 6 0 37 0;
#X connect 7 0 6 0;
#X connect 13 0 15 0;
#X connect 14 0 13 0;
#X connect 15 0 42 0;
#X connect 15 1 21 1;
#X connect 16 0 21 0;
#X connect 17 0 18 0;
#X connect 18 0 14 0;
#X connect 18 1 20 0;
#X connect 19 0 17 0;
#X connect 23 0 16 0;
#X connect 24 0 31 0;
#X connect 25 0 24 0;
#X connect 26 0 38 0;
#X connect 27 0 30 0;
#X connect 28 0 27 0;
#X connect 29 0 31 1;
#X connect 30 0 29 0;
#X connect 31 0 26 0;
#X connect 35 0 34 0;
#X connect 36 0 35 0;
#X connect 37 0 0 1;
#X connect 39 0 2 0;
#X connect 42 0 23 0;
