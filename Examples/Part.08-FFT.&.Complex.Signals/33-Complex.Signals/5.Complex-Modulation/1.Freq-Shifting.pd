#N canvas 346 23 910 528 12;
#X declare -path else;
#X text 116 305 Re1;
#X text 168 305 Im1;
#X text 224 306 Re2;
#X text 265 306 Im2;
#X obj 521 335 cnv 15 298 138 empty empty empty 20 12 0 14 -228856
-66577 0;
#N canvas 0 22 478 328 (subpatch) 0;
#X array \$0-Spectrum 128 float 0;
#X coords 0 3248 127 0 300 140 1 0 0;
#X restore 520 334 graph;
#X text 612 474 500Hz;
#X text 559 473 250Hz;
#X text 519 473 50Hz;
#X text 667 473 750Hz;
#X text 726 473 1KHz;
#X text 771 474 1.25KHz;
#X obj 245 208 nbx 5 16 -2000 2000 0 0 empty empty empty 0 -8 0 13
-228856 -1 -1 0 256;
#X obj 245 278 cos~;
#X obj 245 244 phasor~;
#X obj 144 208 nbx 5 16 -2000 2000 0 0 empty empty empty 0 -8 0 13
-228856 -1 -1 100 256;
#X obj 72 254 adc~ 1;
#X obj 144 254 bl.saw~;
#X obj 149 414 out~;
#X text 83 208 Carrier;
#X text 320 207 Modulator;
#X obj 293 278 sin~;
#N canvas 494 218 502 453 Complex-Modulation 0;
#X obj 291 243 *~;
#X obj 322 243 *~;
#X obj 291 290 -~;
#X text 239 267 Re1*Re2;
#X text 330 267 Im1*Im2;
#X text 330 293 (Re1*Re2 - Im1*Im2);
#X obj 95 142 inlet~;
#X obj 147 142 inlet~;
#X obj 289 142 inlet~;
#X obj 340 142 inlet~;
#X text 99 115 Re1;
#X text 291 112 Re2;
#X text 156 114 Im1;
#X text 343 111 Im2;
#X obj 95 393 outlet~;
#X obj 147 288 +~;
#X obj 94 288 *~;
#X obj 94 242 car2pol~;
#X obj 162 243 car2pol~;
#X obj 94 328 pol2car~;
#X text 365 240 Cartesian;
#X text 40 241 Polar;
#X text 131 25 We just need the real part of the multiplication. Here's
how to calculate this with both the polar and cartesian form., f 30
;
#X connect 0 0 2 0;
#X connect 1 0 2 1;
#X connect 6 0 0 0;
#X connect 6 0 17 0;
#X connect 7 0 1 0;
#X connect 7 0 17 1;
#X connect 8 0 0 1;
#X connect 8 0 18 0;
#X connect 9 0 1 1;
#X connect 9 0 18 1;
#X connect 15 0 19 1;
#X connect 16 0 19 0;
#X connect 17 0 16 0;
#X connect 17 1 15 0;
#X connect 18 0 16 1;
#X connect 18 1 15 1;
#X connect 19 0 14 0;
#X restore 149 346 pd Complex-Modulation;
#X obj 144 285 hilbert~;
#X text 336 273 <= complex sinusoid, f 10;
#N canvas 131 60 278 287 plot 0;
#X obj 53 64 inlet~;
#X obj 53 99 rfft~;
#X obj 132 98 loadbang;
#X obj 132 146 metro 250;
#X obj 132 125 tgl 15 0 empty empty empty 0 -6 0 8 -262144 -1 -1 1
1;
#X obj 89 224 block~ 4096;
#X obj 41 137 car2pol~;
#X obj 51 188 tabwrite~ \$0-Spectrum;
#X connect 0 0 1 0;
#X connect 1 0 6 0;
#X connect 1 1 6 1;
#X connect 2 0 4 0;
#X connect 3 0 7 0;
#X connect 4 0 3 0;
#X connect 6 0 7 0;
#X restore 174 383 pd plot;
#X obj 144 169 initmess 100;
#X obj 683 20 declare -path else;
#X text 41 25 This is the same as a Ring Modulation (RM) \, but with
complex signals. Remember that RM gives us two sideband \, but with
complex signals \, we just have one sideband. Hence \, this process
is also called "Single Sideband Modulation". In practice \, we have
components shifted upwards or downwards depending on the modulation
frequency. So this is also known as a Frequency Shifter., f 56;
#X text 471 58 Do not confuse this with a Pitch Shifter \, because
that requires a proportional shift of all components. When they are
all shifted by the same frequency amount \, we turn a harmonic sound
into an inharmonic one. More precisely \, if we shift it upwards \,
the harmonic ratios are compressed \, and expanded otherwise., f 56
;
#X text 472 157 We can look at this form the perspective of complex
math. By multiplying two complex signals \, we multiply the amplitudes
and sum the phases. Well \, we've seen how summing the phase is the
same as summing the frequencies \, so the modulation frequency gets
added., f 56;
#X text 472 241 Note we need [hilbert~] to transform a real signal
into a complex one. Check [pd Complex-Modulation] for how to implement
this., f 56;
#X connect 12 0 14 0;
#X connect 13 0 22 2;
#X connect 14 0 13 0;
#X connect 14 0 21 0;
#X connect 15 0 17 0;
#X connect 17 0 23 0;
#X connect 21 0 22 3;
#X connect 22 0 18 0;
#X connect 22 0 25 0;
#X connect 23 0 22 0;
#X connect 23 1 22 1;
#X connect 26 0 15 0;
